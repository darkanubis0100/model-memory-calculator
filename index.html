<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GGUF Metadata Reader (Browser)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; }
    h1 { font-size: 1.4rem; margin: 0 0 1rem; }
    .card { border: 1px solid #8883; border-radius: 10px; padding: 1rem; margin-bottom: 1rem; }
    label { display: block; margin: .4rem 0 .2rem; font-weight: 600; }
    input[type="text"] { width: 100%; padding: .5rem; }
    button { padding: .5rem .9rem; margin-right: .5rem; }
    .row { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
    .grow { flex: 1 1 auto; }
    pre { background: #0000000d; padding: .75rem; border-radius: 8px; overflow: auto; max-height: 40vh; }
    .muted { opacity: .8; font-size: .9rem; }
    .ok { color: #0a7; }
    .err { color: #d33; }
    .kv { display: grid; grid-template-columns: max-content 1fr; gap: .25rem .75rem; }
    .kv div:nth-child(odd) { font-weight: 600; }
  </style>
</head>
<body>
  <h1>GGUF Metadata Reader (Static Site)</h1>
  <div class="card">
    <div class="row">
      <div class="grow">
        <label for="url">GGUF URL</label>
        <input id="url" type="text" value="https://huggingface.co/unsloth/Qwen3-30B-A3B-Instruct-2507-GGUF/resolve/main/Qwen3-30B-A3B-Instruct-2507-UD-Q4_K_XL.gguf" />
      </div>
    </div>
    <div class="row" style="margin-top:.5rem">
      <div>
        <label for="file">Or choose a local GGUF file</label>
        <input id="file" type="file" accept=".gguf" />
      </div>
      <div>
        <label for="ctx">Context size (tokens)</label>
        <div style="display:flex; gap:.4rem; align-items:center; flex-wrap:wrap">
          <select id="ctx" style="padding:.4rem .5rem; width: 8rem;">
            <option value="1024">1K</option>
            <option value="2048">2K</option>
            <option value="4096" selected>4K</option>
            <option value="8192">8K</option>
            <option value="16384">16K</option>
            <option value="32768">32K</option>
            <option value="65536">64K</option>
            <option value="131072">128K</option>
            <option value="262144">256K</option>
            <option value="524288">512K</option>
            <option value="1048576">1024K</option>
            <option value="__custom">Custom…</option>
          </select>
          <input id="ctxCustom" type="number" min="1" step="1" placeholder="Tokens" style="width:7rem; padding:.45rem .5rem; display:none" />
        </div>
      </div>
      <div>
        <label for="kvq">KV cache quantization</label>
        <select id="kvq" style="padding:.4rem .5rem;">
          <option value="fp16" selected>FP16/BF16 (4.0 bytes/value)</option>
          <option value="fp32">FP32 (8.0 bytes/value)</option>
          <option value="int8">INT8 (2.0 bytes/value)</option>
          <option value="q6">Q6 (6-bit ≈ 1.5 bytes/value)</option>
          <option value="q5">Q5 (5-bit ≈ 1.25 bytes/value)</option>
          <option value="q4">Q4 (4-bit ≈ 1.0 bytes/value)</option>
        </select>
      </div>
      <label><input type="checkbox" id="verbose" /> Verbose</label>
      <button id="btnUrl">Read URL</button>
      <button id="btnFile">Read File</button>
    </div>
    <div class="muted" style="margin-top:.5rem">Tip: Many hosts (like Hugging Face) support HTTP Range requests needed to avoid downloading the whole file.</div>
  </div>

  <div class="card">
    <h2 style="margin-top:0">Result</h2>
    <div id="result" class="kv"></div>
    <pre id="log"></pre>
  </div>

  <script>
    // ===== Utilities =====
    const logEl = document.getElementById('log');
    function log(...args) { logEl.textContent += args.join(' ') + '\n'; }
    function clearLog() { logEl.textContent = ''; }

    // ===== DataSource base =====
    class DataSource {
      async read(buffer, size) { throw new Error('not implemented'); }
      async seek(position) { throw new Error('not implemented'); }
      eof() { throw new Error('not implemented'); }
      tell() { throw new Error('not implemented'); }
    }

    // Browser File/Blob backed DataSource
    class BrowserFileDataSource extends DataSource {
      constructor(file) {
        super();
        this.file = file; // File or Blob
        this.position = 0;
        this._eof = false;
      }
      async read(buffer, size) {
        const end = Math.min(this.position + size, this.file.size);
        const slice = this.file.slice(this.position, end);
        const arr = new Uint8Array(await slice.arrayBuffer());
        if (arr.length === 0) { this._eof = true; return false; }
        buffer.set(arr.subarray(0, size), 0);
        this.position += arr.length;
        return arr.length === size;
      }
      async seek(position) { this.position = position; this._eof = false; return true; }
      eof() { return this._eof; }
      tell() { return this.position; }
    }

    // URL DataSource with Range fetch and sliding buffer
    const BUFFER_SIZE = 1 << 20; // 1 MiB
    const CHUNK_SIZE = 1 << 18;  // 256 KiB per range
    class UrlDataSource extends DataSource {
      constructor(url, { verbose = false } = {}) {
        super();
        this.url = url;
        this.verbose = verbose;
        this.currentPos = 0;
        this._eof = false;
        this.abortDownload = false;
        this.downloadedData = new Uint8Array(BUFFER_SIZE);
        this.bufferSize = 0; // filled bytes
        this.bufferPos = 0;  // read offset
      }
      async _fetchRange(start, endExclusive) {
        if (this.abortDownload) return new Uint8Array(0);
        const endInclusive = endExclusive - 1;
        if (this.verbose) log(`[HTTP] GET Range: bytes=${start}-${endInclusive}`);
        const res = await fetch(this.url, { headers: { Range: `bytes=${start}-${endInclusive}` } });
        // Some servers reply 206 (Partial Content). 200 is also acceptable but risky if Range ignored.
        if (!res.ok && res.status !== 206 && res.status !== 200) throw new Error(`HTTP error ${res.status}`);
        const arr = new Uint8Array(await res.arrayBuffer());
        if (res.status === 200 && start > 0) {
          // Server ignored Range (dangerous for huge files). We can only slice if we already got the full body.
          if (this.verbose) log('[HTTP] Warning: server ignored Range; received full body with 200.');
          if (arr.length <= start) return new Uint8Array(0);
          return arr.subarray(start, Math.min(arr.length, endExclusive));
        }
        return arr;
      }
      async read(buffer, size) {
        while (this.bufferPos + size > this.bufferSize) {
          if (this.bufferPos >= this.bufferSize) { this.bufferSize = 0; this.bufferPos = 0; }
          if (this.bufferPos > 0 && this.bufferSize > this.bufferPos) {
            this.downloadedData.copyWithin(0, this.bufferPos, this.bufferSize);
            this.bufferSize -= this.bufferPos; this.bufferPos = 0;
          }
          const wantStart = this.currentPos + this.bufferSize;
          const chunkEnd = wantStart + CHUNK_SIZE;
          const neededCapacity = this.bufferSize + CHUNK_SIZE;
          if (neededCapacity > this.downloadedData.length) {
            const newBuf = new Uint8Array(Math.max(this.downloadedData.length * 2, neededCapacity));
            newBuf.set(this.downloadedData.subarray(0, this.bufferSize), 0);
            this.downloadedData = newBuf;
          }
          if (this.abortDownload) { this._eof = true; return false; }
          const arr = await this._fetchRange(wantStart, chunkEnd);
          if (arr.length === 0) { this._eof = true; return false; }
          this.downloadedData.set(arr, this.bufferSize);
          this.bufferSize += arr.length;
        }
        const copySize = Math.min(size, this.bufferSize - this.bufferPos);
        buffer.set(this.downloadedData.subarray(this.bufferPos, this.bufferPos + copySize), 0);
        this.bufferPos += copySize;
        this.currentPos += copySize;
        return copySize === size;
      }
      async seek(position) {
        if (position >= this.currentPos - this.bufferPos && position < this.currentPos + (this.bufferSize - this.bufferPos)) {
          this.bufferPos = position - (this.currentPos - this.bufferPos);
          this.currentPos = position; return true;
        }
        this.bufferSize = 0; this.bufferPos = 0; this.currentPos = position; this._eof = false; return true;
      }
      eof() { return this._eof; }
      tell() { return this.currentPos; }
      setAbortFlag() { this.abortDownload = true; }
    }

    // ===== GGUF parsing =====
    const GGUFType = Object.freeze({
      UINT8: 0,
      INT8: 1,
      UINT16: 2,
      INT16: 3,
      UINT32: 4,
      INT32: 5,
      FLOAT32: 6,
      BOOL: 7,
      STRING: 8,
      ARRAY: 9,
      UINT64: 10,
      INT64: 11,
      FLOAT64: 12,
      MAX_TYPE: 13,
    });

    function readUIntLE(buf, offset, byteLength) {
      let val = 0n;
      for (let i = 0; i < byteLength; i++) val |= BigInt(buf[offset + i]) << BigInt(8 * i);
      return val;
    }
    function formatMemorySize(mb) {
      const n = Number(mb);
      if (n >= 1000) return (n / 1000).toFixed(1) + ' GB';
      return n + ' MB';
    }
    async function readExact(source, size) { const buf = new Uint8Array(size); const ok = await source.read(buf, size); if (!ok) throw new Error('Failed to read required bytes'); return buf; }
    async function readU32(source) { const b = await readExact(source, 4); return Number(readUIntLE(b, 0, 4)); }
    async function readU64(source) { const b = await readExact(source, 8); return Number(readUIntLE(b, 0, 8)); }
    async function readString(source) {
      const len = await readU64(source);
      if (len > 1024 * 1024) throw new Error(`String too long: ${len}`);
      const data = len > 0 ? await readExact(source, Number(len)) : new Uint8Array();
      return new TextDecoder().decode(data);
    }
    async function skipArray(source, elemType) {
      const count = await readU64(source);
      if (count > 1000000) throw new Error(`Array count too large: ${count}`);
      for (let i = 0; i < Number(count); i++) await skipValue(source, elemType);
    }
    async function skipValue(source, type) {
      switch (type) {
        case GGUFType.UINT8:
        case GGUFType.INT8:
          await source.seek(source.tell() + 1); break;
        case GGUFType.UINT16:
        case GGUFType.INT16:
          await source.seek(source.tell() + 2); break;
        case GGUFType.UINT32:
        case GGUFType.INT32:
        case GGUFType.FLOAT32:
          await source.seek(source.tell() + 4); break;
        case GGUFType.BOOL:
          await source.seek(source.tell() + 1); break;
        case GGUFType.STRING: {
          const length = await readU64(source);
          if (length > 1024 * 1024) throw new Error(`String too long: ${length}`);
          await source.seek(source.tell() + Number(length));
          break;
        }
        case GGUFType.ARRAY: {
          const elemTypeVal = await readU32(source);
          if (elemTypeVal >= GGUFType.MAX_TYPE) throw new Error(`Invalid array element type: ${elemTypeVal}`);
          await skipArray(source, elemTypeVal);
          break;
        }
        case GGUFType.UINT64:
        case GGUFType.INT64:
        case GGUFType.FLOAT64:
          await source.seek(source.tell() + 8); break;
        default:
          throw new Error(`Unknown GGUF type: ${type}`);
      }
    }

    async function readModelParams(pathOrFile, { verbose = false } = {}) {
      const isUrl = typeof pathOrFile === 'string';
      let source;
      if (isUrl) {
        let metaUrl = pathOrFile;
        const info = parseSplitInfoFromUrl(metaUrl);
        if (info && info.index > 1) {
          metaUrl = buildSplitUrlFrom(metaUrl, 1, info.width);
          if (verbose) log(`[Split] Non-first shard provided; reading metadata from: ${metaUrl}`);
        }
        source = new UrlDataSource(metaUrl, { verbose });
      } else {
        source = new BrowserFileDataSource(pathOrFile);
      }

      const magic = await readU32(source);
      if (magic !== 0x46554747) { if (verbose) log(`Invalid GGUF file format. Magic number: 0x${magic.toString(16)}`); return null; }

      const version = await readU32(source);
      if (version > 3) { if (verbose) log(`Unsupported GGUF version: ${version}`); return null; }
      if (verbose) log(`GGUF version: ${version}`);

      let tensorCount = 0;
      if (version >= 1) { tensorCount = Number(await readU64(source)); if (verbose) log(`Tensor count: ${tensorCount}`); }

      const metadataCount = Number(await readU64(source));
      if (verbose) log(`Metadata count: ${metadataCount}`);

      const suffixes = [
        '.attention.head_count',
        '.attention.head_count_kv',
        '.block_count',
        '.embedding_length',
        'split.count',
        'general.parameter_count',
      ];

      const params = {};
      const found = { attention_heads: false, kv_heads: false, hidden_layers: false, hidden_size: false, split_count: false, parameter_count: false };

      for (let i = 0; i < metadataCount && !source.eof(); i++) {
        let key;
        try { key = await readString(source); } catch (e) { throw new Error(`Failed to read key: ${e.message}`); }

        const typeVal = await readU32(source);
        if (typeVal >= GGUFType.MAX_TYPE) throw new Error(`Invalid metadata type: ${typeVal} for key: ${key}`);
        const type = typeVal;
        if (verbose) log(`Key: ${key}, Type: ${type}`);

        const matchedSuffix = suffixes.find(s => key.endsWith(s));
        if (matchedSuffix) {
          if (matchedSuffix === '.attention.head_count' && (type === GGUFType.UINT32 || type === GGUFType.INT32)) {
            const value = await readU32(source); params.attention_heads = value; found.attention_heads = true; if (verbose) log(`  Found attention_heads: ${value} (from key: ${key})`);
          } else if (matchedSuffix === '.attention.head_count_kv' && (type === GGUFType.UINT32 || type === GGUFType.INT32)) {
            const value = await readU32(source); params.kv_heads = value; found.kv_heads = true; if (verbose) log(`  Found kv_heads: ${value} (from key: ${key})`);
          } else if (matchedSuffix === '.block_count' && (type === GGUFType.UINT32 || type === GGUFType.INT32)) {
            const value = await readU32(source); params.hidden_layers = value; found.hidden_layers = true; if (verbose) log(`  Found hidden_layers: ${value} (from key: ${key})`);
          } else if (matchedSuffix === '.embedding_length') {
            if (type === GGUFType.UINT64 || type === GGUFType.INT64) {
              const value = await readU64(source); params.hidden_size = value; found.hidden_size = true; if (verbose) log(`  Found hidden_size: ${value} (from key: ${key})`);
            } else if (type === GGUFType.UINT32 || type === GGUFType.INT32) {
              const value = await readU32(source); params.hidden_size = value; found.hidden_size = true; if (verbose) log(`  Found hidden_size: ${value} (from key: ${key})`);
            } else { await skipValue(source, type); }
          } else if (matchedSuffix === 'split.count') {
            if (type === GGUFType.UINT64 || type === GGUFType.INT64) {
              const value = await readU64(source); params.split_count = value; found.split_count = true; if (verbose) log(`  Found split_count: ${value} (from key: ${key})`);
            } else if (type === GGUFType.UINT32 || type === GGUFType.INT32) {
              const value = await readU32(source); params.split_count = value; found.split_count = true; if (verbose) log(`  Found split_count: ${value} (from key: ${key})`);
            } else { await skipValue(source, type); }
          } else if (matchedSuffix === 'general.parameter_count') {
            if (type === GGUFType.UINT64 || type === GGUFType.INT64) {
              const value = await readU64(source); params.parameter_count = value; found.parameter_count = true; if (verbose) log(`  Found parameter_count: ${value} (from key: ${key})`);
            } else if (type === GGUFType.UINT32 || type === GGUFType.INT32) {
              const value = await readU32(source); params.parameter_count = value; found.parameter_count = true; if (verbose) log(`  Found parameter_count: ${value} (from key: ${key})`);
            } else { await skipValue(source, type); }
          } else { await skipValue(source, type); }
        } else { await skipValue(source, type); }

        if (found.attention_heads && found.hidden_layers && found.hidden_size && (found.kv_heads || found.attention_heads)) {
          if (isUrl) { source.setAbortFlag?.(); if (verbose) log('All required metadata found, aborting download'); }
          break;
        }
      }

      if (!found.kv_heads && found.attention_heads) { params.kv_heads = params.attention_heads; found.kv_heads = true; if (verbose) log(`  Using attention_heads as kv_heads: ${params.kv_heads}`); }

      const allFound = found.attention_heads && found.hidden_layers && found.hidden_size;
      if (!allFound) { if (verbose) log('Failed to find all required model parameters.'); return null; }
      return params;
    }

    // ===== Memory usage calculation =====
    function parseSplitInfoFromUrl(url) {
      // Matches: -00001-of-00013 optionally before extension
      const re = /-(\d{2,})-of-(\d{2,})(?=\.|$)/;
      const m = url.match(re);
      if (!m) return null;
      const idxStr = m[1];
      const totalStr = m[2];
      const width = idxStr.length;
      const index = Number(idxStr);
      const total = Number(totalStr);
      if (!Number.isFinite(index) || !Number.isFinite(total) || total <= 0) return null;
      return { index, total, width, patternRe: re };
    }

    function buildSplitUrlFrom(url, newIndex, width) {
      const idxStr = String(newIndex).padStart(width, '0');
      return url.replace(/-(\d{2,})-of-(\d{2,})(?=\.|$)/, `-${idxStr}-of-$2`);
    }

    async function getRemoteFileSize(url, { verbose = false } = {}) {
      try {
        // Try HEAD first (no custom headers, fewer preflight issues)
        const head = await fetch(url, { method: 'HEAD' });
        if (head.ok) {
          const cl = head.headers.get('content-length');
          if (cl) {
            const n = Number(cl);
            if (Number.isFinite(n) && n > 0) return n;
          }
        }
      } catch (e) {
        if (verbose) log('[HEAD error]', e.message || e);
      }
      // Fallback: attempt Range 0-0 to read Content-Range total
      try {
        const res = await fetch(url, { headers: { Range: 'bytes=0-0' } });
        if (!res.ok && res.status !== 206 && res.status !== 200) return 0;
        const cr = res.headers.get('content-range');
        if (cr) {
          // Example: "bytes 0-0/12345"
          const m = cr.match(/\/(\d+)$/);
          if (m) {
            const n = Number(m[1]);
            if (Number.isFinite(n) && n > 0) return n;
          }
        }
        // Some servers return 200 with full body; avoid downloading full content just to find size.
        const cl = res.headers.get('content-length');
        if (cl) {
          const n = Number(cl);
          if (Number.isFinite(n) && n > 0) return n;
        }
      } catch (e) {
        if (verbose) log('[Range 0-0 error]', e.message || e);
      }
      return 0;
    }

    async function totalSplitSizeFromUrl(url, params, { verbose = false } = {}) {
      // Prefer metadata count, else infer from URL
      const info = parseSplitInfoFromUrl(url);
      const total = params?.split_count && params.split_count > 1 ? params.split_count : (info?.total || 0);
      if (!total || total <= 1) return null; // not split
      const width = info?.width || 5;
      const partUrls = [];
      if (info) {
        for (let i = 1; i <= total; i++) partUrls.push(buildSplitUrlFrom(url, i, width));
      } else {
        // Try appending pattern before extension (best-effort)
        const extIdx = url.lastIndexOf('.');
        const base = extIdx > -1 ? url.slice(0, extIdx) : url;
        const ext = extIdx > -1 ? url.slice(extIdx) : '';
        for (let i = 1; i <= total; i++) {
          const idxStr = String(i).padStart(width, '0');
          partUrls.push(`${base}-${idxStr}-of-${String(total).padStart(width, '0')}${ext}`);
        }
      }
      if (verbose) log(`[Split] Detected ${total} parts. Summing sizes...`);
      const sizes = await Promise.all(partUrls.map(u => getRemoteFileSize(u, { verbose })));
      if (sizes.some(s => !s || s <= 0)) { if (verbose) log('[Split] Failed to resolve all part sizes.'); return null; }
      const totalBytes = sizes.reduce((a, b) => a + b, 0);
      return totalBytes;
    }

    async function calculateMemoryUsageFromUrl(url, contextSize, { verbose = false } = {}) {
      const params = await readModelParams(url, { verbose });
      if (!params) return null;
      let sizeBytesTotal = await totalSplitSizeFromUrl(url, params, { verbose });
      if (!sizeBytesTotal) {
        const single = await getRemoteFileSize(url, { verbose });
        if (!single) return null;
        sizeBytesTotal = single;
      }
      const modelSizeMB = Math.floor(sizeBytesTotal / 1_000_000);
      const kvq = getKvqBytesPerValue();
      
      // GQA Adjustment: Scale by (kv_heads / attention_heads)
      const gqaRatio = (params.kv_heads && params.attention_heads) ? (params.kv_heads / params.attention_heads) : 1;
      const kvBytes = kvq * params.hidden_size * params.hidden_layers * contextSize * gqaRatio;
      const kvCacheMB = Math.floor(kvBytes / 1_000_000);

      // Overhead Calculation (Regression from paper: 0.02 GB/B params + 0.15 GB)
      // If parameter_count is missing, we can't estimate overhead accurately, so we default to a safe baseline or 0.
      let overheadMB = 0;
      if (params.parameter_count) {
        const paramsBillion = Number(params.parameter_count) / 1_000_000_000;
        const overheadGB = (0.02 * paramsBillion) + 0.15;
        overheadMB = Math.floor(overheadGB * 1000);
      }

      const totalRequiredMB = modelSizeMB + kvCacheMB + overheadMB;
      const displayString = `${formatMemorySize(totalRequiredMB)} (Model: ${formatMemorySize(modelSizeMB)} + KV: ${formatMemorySize(kvCacheMB)} + Overhead: ${formatMemorySize(overheadMB)})`;
      return { modelSizeMB, kvCacheMB, overheadMB, totalRequiredMB, displayString, hasEstimate: true, kvq: getKvqLabel(), gqaRatio };
    }

    async function calculateMemoryUsageFromFile(file, contextSize, { verbose = false } = {}) {
      const sizeBytes = file?.size || 0;
      if (!sizeBytes) return null;
      const params = await readModelParams(file, { verbose });
      if (!params) return null;
      // If this is one split out of many, estimate total by multiplying
      let totalBytes = sizeBytes;
      if (params.split_count && params.split_count > 1) {
        // Try to use pattern from filename to confirm count; else multiply
        const m = (file.name || '').match(/-(\d{2,})-of-(\d{2,})(?=\.|$)/);
        const inferredTotal = m ? Number(m[2]) : params.split_count;
        if (Number.isFinite(inferredTotal) && inferredTotal > 1) {
          totalBytes = sizeBytes * inferredTotal;
          if (verbose) log(`[Split] Local file appears sharded. Estimating total size as ${inferredTotal} parts.`);
        }
      }
      const modelSizeMB = Math.floor(totalBytes / 1_000_000);
      const kvq = getKvqBytesPerValue();

      // GQA Adjustment
      const gqaRatio = (params.kv_heads && params.attention_heads) ? (params.kv_heads / params.attention_heads) : 1;
      const kvBytes = kvq * params.hidden_size * params.hidden_layers * contextSize * gqaRatio;
      const kvCacheMB = Math.floor(kvBytes / 1_000_000);

      // Overhead Calculation
      let overheadMB = 0;
      if (params.parameter_count) {
        const paramsBillion = Number(params.parameter_count) / 1_000_000_000;
        const overheadGB = (0.02 * paramsBillion) + 0.15;
        overheadMB = Math.floor(overheadGB * 1000);
      }

      const totalRequiredMB = modelSizeMB + kvCacheMB + overheadMB;
      const displayString = `${formatMemorySize(totalRequiredMB)} (Model: ${formatMemorySize(modelSizeMB)} + KV: ${formatMemorySize(kvCacheMB)} + Overhead: ${formatMemorySize(overheadMB)})`;
      return { modelSizeMB, kvCacheMB, overheadMB, totalRequiredMB, displayString, hasEstimate: true, kvq: getKvqLabel(), gqaRatio };
    }

    // ===== UI wiring =====
    const btnUrl = document.getElementById('btnUrl');
    const btnFile = document.getElementById('btnFile');
    const inputUrl = document.getElementById('url');
    const inputFile = document.getElementById('file');
    const verboseEl = document.getElementById('verbose');
  const ctxEl = document.getElementById('ctx');
  const ctxCustomEl = document.getElementById('ctxCustom');
    const kvqEl = document.getElementById('kvq');
    const resultEl = document.getElementById('result');

    function getKvqBytesPerValue() {
      const v = kvqEl?.value || 'fp16';
      switch (v) {
        case 'fp32': return 8.0;
        case 'fp16': return 4.0;
        case 'int8': return 2.0;
        case 'q6': return 1.5;
        case 'q5': return 1.25;
        case 'q4': return 1.0;
        default: return 4.0;
      }
    }
    function getKvqLabel() {
      const map = {
        fp32: 'FP32',
        fp16: 'FP16/BF16',
        int8: 'INT8',
        q6: 'Q6 (6-bit)',
        q5: 'Q5 (5-bit)',
        q4: 'Q4 (4-bit)'
      };
      const v = kvqEl?.value || 'fp32';
      return map[v] || 'FP32';
    }

    function showParams(p) {
      resultEl.innerHTML = '';
      if (!p) { resultEl.textContent = 'No params.'; return; }
      const add = (k, v) => { const kEl = document.createElement('div'); kEl.textContent = k; const vEl = document.createElement('div'); vEl.textContent = String(v); resultEl.appendChild(kEl); resultEl.appendChild(vEl); };
      add('attention_heads', p.attention_heads);
      add('kv_heads', p.kv_heads);
      add('hidden_layers', p.hidden_layers);
      add('hidden_size', p.hidden_size);
      if (p.parameter_count) add('parameter_count', (Number(p.parameter_count) / 1e9).toFixed(2) + 'B');
      if (p.split_count) add('split_count', p.split_count);
    }

    function showUsage(u) {
      if (!u) return;
      const add = (k, v) => { const kEl = document.createElement('div'); kEl.textContent = k; const vEl = document.createElement('div'); vEl.textContent = String(v); resultEl.appendChild(kEl); resultEl.appendChild(vEl); };
      add('modelSizeMB', u.modelSizeMB);
      add('kvCacheMB', u.kvCacheMB);
      add('overheadMB', u.overheadMB);
      add('totalRequiredMB', u.totalRequiredMB);
      add('display', u.displayString);
      if (u.kvq) add('kvQuantization', u.kvq);
      if (u.gqaRatio && u.gqaRatio !== 1) add('GQA Ratio', u.gqaRatio.toFixed(2));
    }

  // Resolve selected context tokens (dropdown or custom numeric input)
    function resolveContextTokens() {
      const sel = ctxEl.value;
      if (sel === '__custom') {
        const v = parseInt(ctxCustomEl.value, 10);
        if (!Number.isFinite(v) || v <= 0) return 1; // minimal safe fallback
        return v;
      }
      return Math.max(1, parseInt(sel || '4096', 10));
    }

  // Toggle custom input visibility when "Custom…" selected
    ctxEl.addEventListener('change', () => {
      if (ctxEl.value === '__custom') {
        ctxCustomEl.style.display = 'inline-block';
        if (!ctxCustomEl.value) ctxCustomEl.focus();
      } else {
        ctxCustomEl.style.display = 'none';
      }
    });

    // Light validation
    ctxCustomEl.addEventListener('blur', () => {
      if (!ctxCustomEl.value) return;
      const v = parseInt(ctxCustomEl.value, 10);
      if (!Number.isFinite(v) || v <= 0) ctxCustomEl.value = '';
    });

    async function handleUrl() {
      clearLog(); resultEl.textContent = 'Working...';
      let url = inputUrl.value.trim();
      const normalized = normalizeHuggingFaceUrl(url);
      if (normalized !== url) {
        log('[Normalize] Hugging Face URL adjusted to raw file path.');
        url = normalized;
        inputUrl.value = normalized;
      }
  const verbose = verboseEl.checked; const ctx = resolveContextTokens();
      try {
        const params = await readModelParams(url, { verbose });
        if (!params) { resultEl.innerHTML = '<span class="err">Failed to read params.</span>'; return; }
        const usage = await calculateMemoryUsageFromUrl(url, ctx, { verbose });
        if (!usage) { resultEl.innerHTML = '<span class="err">Could not determine file size or compute usage (CORS/Range?).</span>'; showParams(params); return; }
        resultEl.innerHTML = '<span class="ok">Success</span>';
        showParams(params);
        showUsage(usage);
      } catch (e) {
        log('[Error]', e.message || e);
        resultEl.innerHTML = '<span class="err">Error: ' + (e.message || e) + '</span>';
      }
    }

  async function handleFile() {
      clearLog(); resultEl.textContent = 'Working...';
  const file = inputFile.files && inputFile.files[0]; const verbose = verboseEl.checked; const ctx = resolveContextTokens();
      if (!file) { resultEl.textContent = 'Choose a file first.'; return; }
      try {
        const params = await readModelParams(file, { verbose });
        if (!params) { resultEl.innerHTML = '<span class="err">Failed to read params.</span>'; return; }
        const usage = await calculateMemoryUsageFromFile(file, ctx, { verbose });
        if (!usage) { resultEl.innerHTML = '<span class="err">Could not compute usage.</span>'; showParams(params); return; }
        resultEl.innerHTML = '<span class="ok">Success</span>';
        showParams(params);
        showUsage(usage);
      } catch (e) {
        log('[Error]', e.message || e);
        resultEl.innerHTML = '<span class="err">Error: ' + (e.message || e) + '</span>';
      }
    }

    btnUrl.addEventListener('click', handleUrl);
    btnFile.addEventListener('click', handleFile);

    function normalizeHuggingFaceUrl(u) {
      if (!u || typeof u !== 'string') return u;
      try {
        if (!u.includes('huggingface.co/')) return u;
        let updated = u.replace(/\/blob\//, '/resolve/');
        updated = updated.replace(/\?raw=1|\?download=1|\?raw=true/i, '');
        if (!/\.gguf($|[?#])/.test(updated)) return u;
        return updated;
      } catch { return u; }
    }

    // Add blur normalization
    inputUrl.addEventListener('blur', () => {
      const before = inputUrl.value;
      const after = normalizeHuggingFaceUrl(before.trim());
      if (after !== before) {
        inputUrl.value = after;
        log('[Normalize] Updated URL on blur.');
      }
    });
  </script>
</body>
</html>
